-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Verify equivalence betweeen hs functions and cpp functions
--   
--   Please see the README on GitHub at
--   <a>https://github.com/roycrippen/coq2hs-cpp-verify#readme</a>
@package coq2hs-cpp-verify
@version 0.1.0.0


-- | Haskell equivalent functions of the CPP functions to test for
--   correctness.
module HsLib

-- | Square a number. For example,
--   
--   <pre>
--   &gt;&gt;&gt; square 9
--   81
--   </pre>
square :: Num a => a -> a

-- | Test whether a, b and c form a Pythagorean triple given that a &lt; b
--   &lt; c. For example,
--   
--   <pre>
--   &gt;&gt;&gt; isTriple 7 24 25
--   True
--   
--   &gt;&gt;&gt; isTriple 7 24 26
--   False
--   </pre>
isTriple :: Int -> Int -> Int -> Bool

-- | List of Pythagorean triples for c &lt; 100. Used to ensure that 20% of
--   the random triple values generated are valid Pythagorean triples.
triples :: [(Int, Int, Int)]

-- | Encode or decode a message with XOR and key. For example,
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Char8 as C
--   
--   &gt;&gt;&gt; applyXorCipher (C.pack "message") (C.pack "my key")
--   "\NUL\FSS\CAN\EOT\RS\b"
--   
--   &gt;&gt;&gt; applyXorCipher (C.pack "\NUL\FSS\CAN\EOT\RS\b") (C.pack "my key")
--   "message"
--   </pre>
applyXorCipher :: ByteString -> ByteString -> ByteString

-- | Encode Unicode code-points to UTF-8 from
--   <a>https://rosettacode.org/wiki/UTF-8_encode_and_decode#Haskell</a>
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; encodeCodepoint 0x00F6
--   [195,182]
--   
--   &gt;&gt;&gt; encodeCodepoint 0x1D11E
--   [240,157,132,158]
--   </pre>
encodeCodepoint :: Int -> [Int]

-- | Decode UTF-8 to Unicode code-points from
--   <a>https://rosettacode.org/wiki/UTF-8_encode_and_decode#Haskell</a>
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; showHex  (decodeToCodepoint [195,182]) ""
--   "F6"
--   
--   &gt;&gt;&gt; showHex  (decodeToCodepoint [240,157,132,158]) ""
--   "1d11e"
--   </pre>
decodeToCodepoint :: [Int] -> Int


-- | Haskell wrapper functions for using CPP directly as inline source
--   code.
module InlineCPP

-- | Inline call to CPP function cn::square. Equivalent to HS function
--   <a>square</a>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; square 9
--   81
--   </pre>
square :: CInt -> IO CInt

-- | Inline call to CPP function cn::isTriple. Equivalent to HS function
--   <a>isTriple</a>. For example,
--   
--   <pre>
--   &gt;&gt;&gt; isTriple 7 24 25
--   True
--   
--   &gt;&gt;&gt; isTriple 7 24 26
--   False
--   </pre>
isTriple :: CInt -> CInt -> CInt -> IO CInt

-- | Inline CPP that sums items in a HS list. For example,
--   
--   <pre>
--   &gt;&gt;&gt; sumVec [10,20,30]
--   100
--   </pre>
sumVec :: [CInt] -> IO CInt

-- | Inline CPP that creates a HS list containing [0 .. (n - 1)]. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; rangeList 4
--   [0,1,2,3]
--   </pre>
rangeList :: Int -> IO [Int]

-- | Inline CPP calls cn::applyXorCipher twice to encoded then decode a
--   message. Demonstrates use of cout and successful round trip use of the
--   XOR cipher. For example,
--   
--   <pre>
--   &gt;&gt;&gt; testApplyXorCipher
--   This is message from cpp std::cout.
--   std::cout -&gt; (cs, key): ('This is the test string...', 'cipher key 123')'
--   std::cout -&gt; applyXorCipher(applyXorCipher(cs, key), key): 'This is the test string...'
--   </pre>
testApplyXorCipher :: IO ()

-- | Inline call to CPP function cn::applyXorCipher. Equivalent to HS
--   function <a>applyXorCipher</a>. Used to encode or decode a message
--   with XOR and key. For example,
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Char8 as C
--   
--   &gt;&gt;&gt; applyXorCipher (C.pack "message") (C.pack "my key")
--   "\NUL\FSS\CAN\EOT\RS\b"
--   
--   &gt;&gt;&gt; applyXorCipher (C.pack "\NUL\FSS\CAN\EOT\RS\b") (C.pack "my key")
--   "message"
--   </pre>
applyXorCipher :: ByteString -> ByteString -> IO ByteString
